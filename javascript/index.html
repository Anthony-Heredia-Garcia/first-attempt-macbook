<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Interactive 3D Correspondence Map</title>
    <style>
        #container {
            width: 800px;
            height: 600px;
            position: relative;
        }
    </style>
</head>
<body>
    <div id="container"></div>

    <script type="module">
        import * as THREE from 'https://cdn.jsdelivr.net/npm/three@0.124/build/three.module.js';
        import { OrbitControls } from 'https://cdn.jsdelivr.net/npm/three@0.124/examples/jsm/controls/OrbitControls.js';

        // Read data exported from Python
        let rowCoordinates = [
            [0, 0, 0],
            [2, 1, -3],
            [-1, 2, -2],
            [4, 0, -1],
            [0, 3, 3],
            [-3, -1, -1],
            // Add more coordinates as needed
        ];

        // Initialize Three.js scene
        let scene = new THREE.Scene();
        scene.background = new THREE.Color(0xffffff); // Set background color to white

        let camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        let renderer = new THREE.WebGLRenderer();
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.getElementById('container').appendChild(renderer.domElement);

        // Create grid helpers for X, Y, and Z axes
        const gridSize = 9;

        let rightWall = new THREE.GridHelper(gridSize, gridSize);
        rightWall.rotation.z = Math.PI / 2;
        rightWall.position.set(gridSize / 2, 0, 0);
        scene.add(rightWall);

        let leftWall = new THREE.GridHelper(gridSize, gridSize);
        leftWall.rotation.z = Math.PI / 2;
        leftWall.position.set(-gridSize / 2, 0, 0);
        scene.add(leftWall);

        let topWall = new THREE.GridHelper(gridSize, gridSize);
        topWall.rotation.y = Math.PI / 2;
        topWall.position.set(0, gridSize/2, 0, 0);
        scene.add(topWall);

        let bottomWall = new THREE.GridHelper(gridSize, gridSize);
        bottomWall.rotation.y = Math.PI / 2;
        bottomWall.position.set(0, -gridSize/2, 0, 0);
        scene.add(bottomWall);

        // Create a cube mesh with grid lines inside it
        let cubeSize = 10;
        let cubeGeometry = new THREE.BoxGeometry(cubeSize, cubeSize, cubeSize);
        let cubeEdges = new THREE.EdgesGeometry(cubeGeometry);
        let cubeLines = new THREE.LineSegments(cubeEdges, new THREE.LineBasicMaterial({ color: 0x000000 }));
        scene.add(cubeLines);

        // Create 3D objects based on row coordinates
        rowCoordinates.forEach(function(coord) {
            let geometry = new THREE.SphereGeometry(0.2, 32, 32); // Use spheres for points
            let material = new THREE.MeshBasicMaterial({ color: 0xff0000 }); // Red color
            let sphere = new THREE.Mesh(geometry, material);
            sphere.position.set(coord[0], coord[1], coord[2]);
            scene.add(sphere);
        });

        // Add lighting
        let ambientLight = new THREE.AmbientLight(0xffffff, 0.5);
        //scene.add(ambientLight);

        let directionalLight = new THREE.DirectionalLight(0xffffff, 0.5);
        //scene.add(directionalLight);

        // Set camera position
        camera.position.z = 15;

        // Add controls for interactivity
        let controls = new OrbitControls(camera, renderer.domElement);

        // Render function
        function animate() {
            requestAnimationFrame(animate);
            renderer.render(scene, camera);
            controls.update(); // Update controls
        }
        animate();
    </script>
</body>
</html>
